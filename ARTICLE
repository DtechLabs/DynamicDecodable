Have you ever encountered a situation where your app stops working properly or even crashes (assuming you are not a fan of defensive programming, of course) because the backend changes the data structure in its responses? Unfortunately, I have faced this often.

You might rightly argue that this shouldn’t happen, that the backend should adhere to agreed structures and support versioning. But in the real world, it does happen.

Why does this happen? Swift has a very smart and powerful Codable protocol, but at its core, Swift is a strictly typed language. This is the primary issue. For example, we might receive a bool in the same structure in three different forms like [true | false], [1 | 0], or even as strings ["true" | "false"]. The same problem exists for numbers, which can be either numeric values or string representations. I don’t even want to list all the variations for Date!

The second issue is that endpoints for similar actions can return a very similar set of properties, but with slight differences.

So, how can we navigate these challenges?

Sure, you can use optional properties, define independent structures for each endpoint, or find a framework to handle it for you. But I prefer to follow the DRY principle and like to have control over every line of code in my app. That's why I created a very small solution for this: DynamicDecodable.

DynamicDecodable is an enum with the main types of properties that can be in JSON:

int
string
bool
double
array
dictionary
null
Additionally, I added some syntactic sugar to write clean and readable code.

Here is a sample of how to use it:

swift
Copy code
let item = try DynamicDecodable(jsonData)
That's all. We don't need to define any structures. Do not forget that we must map the received data into a database or other structure for use in the view to divide the network layer.

For example:

swift
Copy code
let name = item.name.stringValue
let id = item.id.intValue
let amount = item.decimalValue // I always use Decimal because Double has rounding errors
let createdAt = item.createdAt.date
// and so on.

// or, if you add some syntactic sugar, which is useful when updating data in a defined structure:
let id: Int <- item.id
If we are working with arrays:

swift
Copy code
let asset1 = item.assets?[0]
And YES, all dynamic members are optional. So we avoid any crashes here.

Also, we can check for equality of simple types like int, string, bool, date, double, and decimal. For example:

swift
Copy code
if item.name == "user" {
    ...
}

if item.amount > 100 {
    ...
}

If you have any questions or proposals to add functionality, please don't hesitate to contact me!

You can find the framework here: [DynamicDecodable]
